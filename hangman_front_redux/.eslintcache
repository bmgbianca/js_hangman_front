[{"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/serviceWorker.js":"1","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/services/requestsServices.js":"2","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/idSlice.js":"3","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/app/store.js":"4","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameModeSlice.js":"5","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameLevelSlice.js":"6","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/GamePage/GamePage.js":"7","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/LevelChoicePage/LevelChoicePage.js":"8","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/LoginPage/LoginPage.js":"9","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/App.js":"10","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/GamePage/GamePageHelpers.js":"11","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/index.js":"12","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/FriendPlayPage/FriendPlayPage.js":"13","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameChoiceSlice.js":"14","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/ChallengerPage/ChallengerPage.js":"15","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/ScoreModal/ScoreModal.js":"16","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/ChallengedPage/ChallengedPage.js":"17","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameScoreSlice.js":"18"},{"size":5141,"mtime":1610459933295,"results":"19","hashOfConfig":"20"},{"size":923,"mtime":1612476730310,"results":"21","hashOfConfig":"20"},{"size":391,"mtime":1610461811345,"results":"22","hashOfConfig":"20"},{"size":554,"mtime":1612371958876,"results":"23","hashOfConfig":"20"},{"size":418,"mtime":1610462244085,"results":"24","hashOfConfig":"20"},{"size":426,"mtime":1610472723871,"results":"25","hashOfConfig":"20"},{"size":13030,"mtime":1612477225855,"results":"26","hashOfConfig":"20"},{"size":1503,"mtime":1612476676204,"results":"27","hashOfConfig":"20"},{"size":1570,"mtime":1612377757483,"results":"28","hashOfConfig":"20"},{"size":1324,"mtime":1612377455570,"results":"29","hashOfConfig":"20"},{"size":2335,"mtime":1610739813395,"results":"30","hashOfConfig":"20"},{"size":644,"mtime":1610459933294,"results":"31","hashOfConfig":"20"},{"size":1653,"mtime":1612380027215,"results":"32","hashOfConfig":"20"},{"size":434,"mtime":1611780096666,"results":"33","hashOfConfig":"20"},{"size":5353,"mtime":1612809933668,"results":"34","hashOfConfig":"20"},{"size":1444,"mtime":1612391619185,"results":"35","hashOfConfig":"20"},{"size":1963,"mtime":1612459166941,"results":"36","hashOfConfig":"20"},{"size":505,"mtime":1612213939364,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"15n1m31",{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"40"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"73","messages":"74","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/serviceWorker.js",[],["81","82"],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/services/requestsServices.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/idSlice.js",[],["83","84"],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/app/store.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameModeSlice.js",[],["85","86"],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameLevelSlice.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/GamePage/GamePage.js",["87","88","89"],"import React, { useEffect, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  generalLettersArray,\n  simplifyLetters,\n  defineSelector,\n  disableLetters,\n} from './GamePageHelpers';\nimport {\n  getDatabaseWord,\n  getFriendWord,\n  postScore,\n} from '../../services/requestsServices';\nimport { selectId, changeId } from '../../features/idSlice';\nimport { selectGameLevel } from '../../features/gameLevelSlice';\nimport {\n  selectGameScore,\n  changeGameScore,\n  resetGameScore,\n} from '../../features/gameScoreSlice';\nimport ScoreModal from '../ScoreModal/ScoreModal';\nimport './GamePage.css';\n\nexport default function GamePage() {\n  const [roundWordLetters, setRoundWordLetters] = useState([]);\n  const [\n    roundWordLettersWithoutHyphen,\n    setRoundWordLettersWithoutHyphen,\n  ] = useState([]);\n  const [lettersCount, setLettersCount] = useState(0);\n  const [countDown, setCountDown] = useState(20);\n  const [timeInterval, setTimeInterval] = useState(null);\n  const [shortPause, setShortPause] = useState(null);\n  const [isDisabled, setIsDisabled] = useState(true);\n  const [isScoreModalOpen, setIsScoreModalOpen] = useState(false);\n  const [postFinalScore, setPostFinalScore] = useState(false);\n\n  /*Seleção das variáveis globais do Redux - id e gameLevel indicam como \n  deve ser puxada a palavra da base de dados para o jogo, enquanto gameScore \n  é para guardar a pontuação do jogador que será postada na base de dados.*/\n  const id = useSelector(selectId);\n  const gameLevel = useSelector(selectGameLevel);\n  const gameScore = useSelector(selectGameScore);\n\n  const dispatch = useDispatch();\n\n  const history = useHistory();\n\n  /*Aqui, selecionamos os elementos do HTML, que sofrerão mudanças ao longo do \n  jogo, como aparecer, desaparecer ou receber uma outra source.*/\n  const hangImage = document.querySelector('.hang');\n  const messageParagraph = document.getElementById('message');\n  const x = document.getElementById('bigX');\n  const mainContent = document.getElementById('main');\n  const endGameDiv = document.getElementById('endGame');\n  const timerDiv = document.getElementById('timerDiv');\n  const timer = document.querySelector('.countDownParagraph');\n  const bell = document.getElementById('erro');\n  const claps = document.getElementById('aplausos');\n  const awnSound = document.getElementById('awn');\n\n  /*Esta variável será um timeInterval, que vai ser limpo (clearInterval) \n  no retorno do primeiro useEffect (abaixo).*/\n  let countDownChange;\n\n  /*Este useEffect puxa a palavra da base de dados de acordo com a escolha do \n  jogador e inicia o timer para a escolha da primeira letra.*/\n  useEffect(() => {\n    const getRoundWord = async () => {\n      const gameOption = window.location.href.split('/')[3];\n      const urlGameInfo = window.location.href.split('/').pop();\n      let response;\n      let word;\n      if (gameOption === 'play-with-a-friend') {\n        response = await getFriendWord(id || urlGameInfo);\n        word = response.data;\n      } else {\n        response = await getDatabaseWord(gameLevel || urlGameInfo);\n        word = response.data.word;\n        dispatch(changeId(response.data.id));\n      }\n      const roundWord = word;\n      const roundWordLettersArray = [];\n      for (let i = 0; i < roundWord.length; i++) {\n        roundWordLettersArray.push(roundWord[i]);\n      }\n      setRoundWordLetters(roundWordLettersArray);\n      removeHyphens(roundWordLettersArray);\n    };\n    getRoundWord();\n    if (roundWordLetters) {\n      countDownChange = setInterval(() => {\n        setCountDown((prevCountDown) => prevCountDown - 1);\n      }, 1000);\n      setTimeInterval(countDownChange);\n    }\n    return () => {\n      clearInterval(countDownChange);\n    };\n  }, []);\n\n  /*Esta função, chamada no useEffect acima, deixa os hífens da palavra visíveis, \n  caso haja, e setta a variável de estado com as letras da palavra do jogo sem o hífen.*/\n  const removeHyphens = (lettersArray) => {\n    if (lettersArray.includes('-')) {\n      const hyphen = document.querySelectorAll('[alt=\"-\"]');\n      for (let i = 0; i < hyphen.length; i++) {\n        const currentHyphen = hyphen[i];\n        currentHyphen.classList.remove('disabled');\n      }\n      const noHyphen = lettersArray.filter((letter) => {\n        return letter !== '-';\n      });\n      setRoundWordLettersWithoutHyphen(noHyphen);\n    } else {\n      setRoundWordLettersWithoutHyphen(roundWordLetters);\n    }\n  };\n\n  /*Com este useEffect, garantimos que a modal só será aberta depois de a \n  pontuação final ter sido enviada para a base de dados.*/\n  useEffect(() => {\n    const sendScoreToDB = async () => {\n      await postScore(id, gameScore);\n      setIsScoreModalOpen(true);\n    };\n    if (postFinalScore) {\n      sendScoreToDB();\n    }\n  }, [postFinalScore]);\n\n  /*Este useEffect dispara as ações que devem acontecer, caso o tempo para o\n  jogador escolher uma letra chegue ao final.*/\n  useEffect(() => {\n    if (timer) {\n      if (countDown === 5) {\n        timer.classList.add('alert');\n      } else if (countDown === 20) {\n        timer.classList.remove('alert');\n      }\n    }\n\n    if (countDown === 0) {\n      bell.play();\n      x.classList.remove('noShow');\n      x.classList.add('bigX');\n      mainContent.classList.remove('container');\n      mainContent.classList.add('noShow');\n\n      setShortPause(\n        setTimeout(() => {\n          x.classList.remove('bigX');\n          x.classList.add('noShow');\n          mainContent.classList.remove('noShow');\n          mainContent.classList.add('container');\n          bell.pause();\n          bell.currentTime = 0;\n          handleMistake('');\n        }, 1500)\n      );\n    }\n    return () => {\n      clearInterval(shortPause);\n    };\n  }, [countDown]);\n\n  //Esta é a função disparada quando o jogador escolher uma letra.\n  const handleLetterChoice = (e) => {\n    const element = e.target;\n    const chosenLetter = element.id;\n\n    //A função simplifyLetters remove todos os acentos, cedilha e til das letras da palavra.\n    const simplifiedRoundWordLetters = simplifyLetters(roundWordLetters);\n\n    if (\n      !element.className.includes('out') &&\n      !element.className.includes('remaining')\n    ) {\n      if (simplifiedRoundWordLetters.includes(chosenLetter)) {\n        const selector = defineSelector(chosenLetter);\n        const chosenLetterInHTML = document.querySelectorAll(selector);\n        let newCount = lettersCount;\n\n        dispatch(changeGameScore(50));\n        for (let i = 0; i < chosenLetterInHTML.length; i++) {\n          const currentLetter = chosenLetterInHTML[i];\n          currentLetter.classList.remove('disabled');\n          newCount += 1;\n        }\n\n        //Esta condicional identifica se a palavra está completa e, portanto, o jogador venceu.\n        if (newCount === simplifiedRoundWordLetters.length) {\n          clearInterval(timeInterval);\n          if (hangImage.src === '/forcas/forca_0.png') {\n            dispatch(changeGameScore(100));\n          }\n          messageParagraph.textContent = 'PARABÉNS!! VOCÊ GANHOU!';\n          disableLetters(generalLettersArray, chosenLetter);\n          setPostFinalScore(true);\n          setIsDisabled(false);\n          timerDiv.classList.remove('timerDiv');\n          timerDiv.classList.add('noShow');\n          endGameDiv.classList.remove('noShow');\n          endGameDiv.classList.add('endGame');\n          claps.play();\n        } else {\n          setCountDown(20);\n        }\n        setLettersCount(newCount);\n      } else {\n        handleMistake(chosenLetter);\n      }\n      element.classList.add('out');\n    } else {\n      return;\n    }\n  };\n\n  /*A tratativa para o caso de a letra escolhida não constar na palavra foi colocada \n  à parte da função anterior, que lida com a escolha de uma letra, porque este bloco\n  de código também deverá ser executado caso o jogador não escolha nenhuma letra,\n  mas acabe seu tempo limite para a escolha de uma letra (o countDown) */\n  const handleMistake = (chosenLetter) => {\n    dispatch(changeGameScore(-10));\n\n    const currentImageNumber = Number(hangImage.title);\n    const nextNumber = currentImageNumber + 1;\n    hangImage.src = `/forcas/forca_${nextNumber}.png`;\n    hangImage.title = nextNumber;\n\n    /*Esta condicional identifica se chegamos à imagem final, com o enforcado,\n    o que significa que o jogo acabou e o jogador perdeu.*/\n    let limitNumber;\n    if (window.location.href.split('/')[3] === 'single-player') {\n      if (window.location.href.split('/').pop() === 'expert') {\n        limitNumber = 5;\n      } else {\n        limitNumber = 8;\n      }\n    } else {\n      limitNumber = 8;\n    }\n\n    if (currentImageNumber === limitNumber) {\n      clearInterval(timeInterval);\n      dispatch(resetGameScore());\n      messageParagraph.textContent = 'GAME OVER! VOCÊ PERDEU!';\n      setIsDisabled(false);\n      setPostFinalScore(true);\n      awnSound.play();\n      timerDiv.classList.remove('timerDiv');\n      timerDiv.classList.add('noShow');\n      endGameDiv.classList.remove('noShow');\n      endGameDiv.classList.add('endGame');\n\n      for (let i = 0; i < roundWordLettersWithoutHyphen.length; i++) {\n        const letter = roundWordLettersWithoutHyphen[i];\n        const wordLettersInHTML = document.querySelectorAll(`[alt=${letter}]`);\n\n        if (wordLettersInHTML[0].className.includes('disabled')) {\n          for (let i = 0; i < wordLettersInHTML.length; i++) {\n            const letterElement = wordLettersInHTML[i];\n            letterElement.classList.remove('disabled');\n            letterElement.classList.add('remaining');\n          }\n        }\n      }\n      disableLetters(generalLettersArray, chosenLetter);\n    } else {\n      setCountDown(20);\n    }\n  };\n\n  const handlePlayAgain = () => {\n    clearInterval(timeInterval);\n    history.push('/');\n  };\n\n  const closeModal = () => {\n    dispatch(resetGameScore());\n    setIsScoreModalOpen(false);\n  };\n\n  return (\n    <>\n      <audio id=\"erro\" src=\"/erro.m4a\" type=\"audio/m4a\" />\n      <audio id=\"aplausos\" src=\"/aplausos.m4a\" type=\"audio/m4a\" />\n      <audio id=\"awn\" src=\"/awn.m4a\" type=\"audio/m4a\" />\n      <section className=\"allLetters\">\n        {generalLettersArray.map((letter, i) => {\n          return (\n            <img\n              key={0 + letter + i}\n              id={letter}\n              className=\"shadow-lg lettersToChoose\"\n              src={`/letras/${letter}.png`}\n              alt=\"letra\"\n              type=\"image/png\"\n              onClick={handleLetterChoice}\n              onMouseEnter={(e) => e.target.classList.remove('shadow-lg')}\n              onMouseLeave={(e) => e.target.classList.add('shadow-lg')}\n            />\n          );\n        })}\n      </section>\n      <h1 id=\"bigX\" className=\"noShow\">\n        X\n      </h1>\n      <main id=\"main\" className=\"container\">\n        <img\n          src=\"/forcas/forca_0.png\"\n          className=\"hang\"\n          title={0}\n          alt=\"forca\"\n          type=\"image/png\"\n        />\n        <section className=\"secondColumn\">\n          <div id=\"timerDiv\" className=\"timerDiv\">\n            <p className=\"timeMessage\">Tempo para escolher a próxima letra:</p>\n            <p className=\"countDownParagraph\">{countDown}</p>\n          </div>\n          <div id=\"endGame\" className=\"noShow\">\n            <p className=\"message\" id=\"message\"></p>\n            <div className=\"endButtonsDiv\">\n              <button\n                className=\"btn viewScoreButton\"\n                type=\"button\"\n                disabled={isDisabled}\n                onClick={() => setIsScoreModalOpen(true)}\n              >\n                <i className=\"bi-award-fill\"></i>\n                <p>PONTUAÇÃO</p>\n              </button>\n              <button\n                className=\"btn playAgainButton\"\n                type=\"button\"\n                disabled={isDisabled}\n                onClick={handlePlayAgain}\n              >\n                <i className=\"bi-arrow-clockwise\"></i>\n                JOGAR <p>NOVAMENTE!</p>\n              </button>\n            </div>\n          </div>\n          <div className=\"dashes\">\n            {roundWordLetters.map((letter, i) => {\n              return (\n                <div key={0 + letter + i} className=\"letterDashPair\">\n                  <img\n                    src={`/letras/${letter}.png`}\n                    className=\"disabled gameLetter\"\n                    alt={letter}\n                    type=\"image/png\"\n                  />\n                  <img\n                    key={1 + letter + i}\n                    src=\"/forcas/dash.png\"\n                    alt=\"dash\"\n                    type=\"image/png\"\n                    className=\"dash\"\n                  />\n                </div>\n              );\n            })}\n          </div>\n        </section>\n        {isScoreModalOpen && (\n          <ScoreModal\n            source={false}\n            message=\"SUA PONTUAÇÃO É:\"\n            closeModal={closeModal}\n          />\n        )}\n      </main>\n    </>\n  );\n}\n","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/LevelChoicePage/LevelChoicePage.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/LoginPage/LoginPage.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/App.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/GamePage/GamePageHelpers.js",[],["90","91"],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/index.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/FriendPlayPage/FriendPlayPage.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameChoiceSlice.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/ChallengerPage/ChallengerPage.js",["92"],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/ScoreModal/ScoreModal.js",["93"],"import React, { useState, useEffect } from 'react';\nimport Modal from 'react-modal';\nimport { selectId } from '../../features/idSlice';\nimport { useSelector } from 'react-redux';\nimport { getScore } from '../../services/requestsServices';\nimport './ScoreModal.css';\n\nModal.setAppElement('#root');\n\nexport default function ScoreModal({ source, message, closeModal }) {\n  const [score, setScore] = useState(null);\n  const [scoreClass, setScoreClass] = useState('longMessage');\n  const id = useSelector(selectId);\n\n  useEffect(() => {\n    getFriendScore();\n  }, [id]);\n\n  const getFriendScore = async () => {\n    const friendScore = await getScore(id);\n    setScore(friendScore.data);\n    if (typeof friendScore.data === 'number') {\n      setScoreClass('shortMessage');\n    } else {\n      setScoreClass('longMessage');\n    }\n  };\n\n  const handleClose = (e) => {\n    if (e.key === 'Escape') {\n      closeModal();\n    }\n  };\n\n  return (\n    <div onKeyUp={handleClose}>\n      <Modal className=\"modal\" isOpen={true}>\n        <button className=\"btn btn-sm closeButton\" onClick={closeModal}>\n          X\n        </button>\n        <h1>{message}</h1>\n        <div>\n          <p className={scoreClass}>{score}</p>\n        </div>\n        {source && (\n          <button className=\"btn btn-lg refreshButton\" onClick={getFriendScore}>\n            ATUALIZAR <i className=\"bi-arrow-clockwise\"></i>\n          </button>\n        )}\n      </Modal>\n    </div>\n  );\n}\n","/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/components/ChallengedPage/ChallengedPage.js",[],"/Users/bianca/Outros/js_hangman/js_hangman_front/hangman_front_redux/src/features/gameScoreSlice.js",[],["94","95"],{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","replacedBy":"99"},{"ruleId":"96","replacedBy":"100"},{"ruleId":"98","replacedBy":"101"},{"ruleId":"96","replacedBy":"102"},{"ruleId":"98","replacedBy":"103"},{"ruleId":"104","severity":1,"message":"105","line":93,"column":25,"nodeType":"106","endLine":95,"endColumn":15},{"ruleId":"104","severity":1,"message":"107","line":131,"column":6,"nodeType":"108","endLine":131,"endColumn":22,"suggestions":"109"},{"ruleId":"104","severity":1,"message":"110","line":166,"column":6,"nodeType":"108","endLine":166,"endColumn":17,"suggestions":"111"},{"ruleId":"96","replacedBy":"112"},{"ruleId":"98","replacedBy":"113"},{"ruleId":"104","severity":1,"message":"114","line":31,"column":18,"nodeType":"106","endLine":31,"endColumn":50},{"ruleId":"104","severity":1,"message":"115","line":17,"column":6,"nodeType":"108","endLine":17,"endColumn":10,"suggestions":"116"},{"ruleId":"96","replacedBy":"117"},{"ruleId":"98","replacedBy":"118"},"no-native-reassign",["119"],"no-negated-in-lhs",["120"],["119"],["120"],["119"],["120"],"react-hooks/exhaustive-deps","Assignments to the 'countDownChange' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","CallExpression","React Hook useEffect has missing dependencies: 'gameScore' and 'id'. Either include them or remove the dependency array.","ArrayExpression",["121"],"React Hook useEffect has missing dependencies: 'bell', 'handleMistake', 'mainContent.classList', 'shortPause', 'timer', and 'x.classList'. Either include them or remove the dependency array.",["122"],["119"],["120"],"Assignments to the 'inputField' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","React Hook useEffect has a missing dependency: 'getFriendScore'. Either include it or remove the dependency array.",["123"],["119"],["120"],"no-global-assign","no-unsafe-negation",{"desc":"124","fix":"125"},{"desc":"126","fix":"127"},{"desc":"128","fix":"129"},"Update the dependencies array to be: [gameScore, id, postFinalScore]",{"range":"130","text":"131"},"Update the dependencies array to be: [bell, countDown, handleMistake, mainContent.classList, shortPause, timer, x.classList]",{"range":"132","text":"133"},"Update the dependencies array to be: [getFriendScore, id]",{"range":"134","text":"135"},[4825,4841],"[gameScore, id, postFinalScore]",[5777,5788],"[bell, countDown, handleMistake, mainContent.classList, shortPause, timer, x.classList]",[559,563],"[getFriendScore, id]"]